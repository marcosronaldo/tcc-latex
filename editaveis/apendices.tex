\begin{apendicesenv}

\partapendices

\chapter{Android e a Engenharia de software}
\label{ap:android_esw}

\section{Design e Componentes Android}

O Android provê um \textit{framework} para desenvolver aplicativos baseado nos componentes descritos no início deste capítulo. Os aplicativos são construídos com qualquer combinação desses componentes, que podem ser utilizados individualmente, sem a presença dos demais. Cada um dos componentes pode ser uma entrada para o aplicativo sendo desenvolvido.

A comunicação direta entre os componentes de cada aplicativo é feita por meio do \textit{Binder}\footnote{\url{http://developer.android.com/guide/components/bound-services.html}}, mecanismo de comunicação entre processos. O \textit{Binder} comunica processos através da troca de mensagens (chamadas \textit{parcels}), que podem referenciar dados primitivos e objetos da API assim como referencias para outros objetos \textit{binder}. De forma geral, um \textit{service} no Android pode ter sua interface definida em AIDL (\textit{Android Interface Definition Language}), e uma aplicação que tiver referencia para o \textit{binder} desse \textit{service} pode executar chamadas de procedimento remoto (\textit{RPC - remote procedure calls}) para qualquer método definido nessa interface AIDL de forma síncrona. Embora o \textit{binder} apresente acesso direto para alguns componentes, essa comunicação pode ser feita de forma indireta utilizando \textit{Intents}. Como descrito neste capítulo, Intents são geralmente recebidos por \textit{receivers} que estão registrados para recebê-los. Esse registro é feito por meio de \textit{Intent Filters}. Entretanto, \textit{activities} e \textit{services} também podem utilizar desse mecanismo para ser iniciados e finalizados. Quando um \textit{Intent} é enviado ao sistema via \textit{broadcast}, ele é recebido pelo sistema e resolvido pelo \textit{Activity Manager Service} (AMS), que seleciona o melhor componente para tratá-lo, e então inicia o componente que o recebeu independente da aplicação a que ele pertença. Assim como já descrito, permissões podem ser criadas para restringir essa comunicação, mas a principio qualquer componente pode receber um \textit{intent} de qualquer outra.  Embora essas formas de comunicação entre processos sejam recomendadas, o sistema Android também suporta mecanismos de comunicação padrões do Linux como \textit{sockets} e \textit{pipes} \cite{heuser2014}.

Ainda que os componentes sejam geralmente registrados no sistema através do \textit{AndroidManifest.xml}, \textit{BroadcastReceivers} podem ser registrados dinamicamente dentro do ciclo de vida da aplicação. Isso quer dizer que é possível criar um \textit{receiver} projetado para funcionar apenas enquanto a aplicação estiver em execução. Esse \textit{BroadcastReceiver} então é registrado por linha de comando da API e desativado quando requisitado, criando uma janela de tempo onde se deseja que esse componente funcione.

De forma geral, para desenhar uma arquitetura para sistema Android deve-se levar em conta todos esses componentes e conhecer bem sua aplicabilidade e a comunicação entre os mesmos. Se for necessário ter algum processo em background independente de \textit{feedback} do usuário, por exemplo, deve-se utilizar do componente \textit{service}. Caso contrário, quando o usuário fechar a interface gráfica do aplicativo, o aplicativo terá sua execução pausada e seu estado salvo para retorno posterior, deixando de executar alguma tarefa que não deveria ter sido interrompida. Como um exemplo mais palpável, o aplicativo do facebook precisa necessariamente utilizar de um \textit{service} para que, mesmo quando não estiver em foco no sistema, notificações de mensagens e atualizações de status cheguem na tela do usuário.

Embora pareça restringir o design de aplicativos, o uso desses componentes unifica a forma com que os aplicativos são desenvolvidos. A API do Android já disponibiliza acesso a vários recursos de hardware do sistema na forma de componentes, e assim como é possível utilizar os componentes do sistema, é possível utilizar componentes de qualquer outra aplicação da mesma maneira - se a permissão for concedida- , e criar os seus próprios componentes para uso de terceiros de forma padronizada. Em suma, é tão fácil usar componentes criados por alguma aplicação qualquer quanto componentes internos do sistema graças ao \textit{framework} de desenvolvimento Android.

\section{Interface de usuário}

O design de interface deve ser realizado com o intuito de alcançar usuários com capacidades motoras restritas, e outras limitações como problemas de visão ou audição. Dependendo do público alvo do aplicativo, esses aspectos devem ser considerados.

Com o desafio de fazer uso do pequeno espaço de tela, o design da interface gráfica apresenta mais importância do que jamais teve no desenvolvimento de aplicativos móveis \cite{eswissues}. Usuários estão sempre tentando acessar várias tarefas diferentes, e geralmente tem baixa tolerância a aplicativos instáveis ou não responsivos, mesmo que gratuitos \cite{eswmobile}. 

A base da interface gráfica de usuário no Android é construída em cima da classe \textit{View}, sendo que todos os elementos visíveis na tela, e alguns não visíveis, são derivados dessa classe \cite{androidarch2010}. O sistema Android disponibiliza vários componentes gráficos como botões, caixas de texto, imagens, caixas de seleção de dados, calendário, componentes de mídia (áudio e vídeo), entre outros, e a interface gráfica é construída em cima desses componentes gráficos, que podem ser customizados para um comportamento ou aparência um pouco diferente se assim for desejado, estendendo e customizando suas respectivas classes em Java. Existe um padrão de design\footnote{\url{https://developer.android.com/design/get-started/principles.html}} que é recomendado que seja seguido.

A interface gráfica do usuário é construída geralmente em formato XML utilizando esses componentes gráficos já disponibilizados na API. Esses arquivos XML são então carregados pela API em Java quando necessário, e podem ser editados dinamicamente através da API, em linguagem Java.

Todo projeto de aplicativo Android possui um arquivo em Java chamado \textit{R} (\textit{Resources}) autogerado que contém identificação dos recursos do aplicativo. Cada componente gráfico disponibilizado na API e utilizado nos arquivos XML pode ser identificado de qualquer local do aplicativo pelo seu ID atribuído no arquivo XML. Dessa forma, é possível localizar facilmente dentro de sua \textit{Activity} cada componente para ser carregado, modificado e utilizado.

\section{Construção}

Para construção de aplicativos para a plataforma Android, o Google disponibiliza um kit de desenvolvimento de aplicativos chamado Android SDK~\footnote{\url{https://developer.android.com/sdk}} (\textit{Software Development Kit}). Ele provê as bibliotecas da API e as ferramentas necessárias para construir, testar e debugar aplicativos. Android SDK está disponível para os sistemas operacionais Linux, MAC e Windows.

A ferramenta oficial para desenvolvimento de aplicativos Android é o \textit{Android Studio}~\footnote{\url{https://developer.android.com/sdk/installing/studio.html}}. O Android SDK atualmente é baixado instalado juntamente com o instalador do Android Studio. O IDE Eclipse ainda pode ser utilizado para desenvolvimento juntamente com \textit{plugin} ADT (\textit{Android Development Tools}), que inclui as ferramentas de visualização de interface em XML, ferramentas de \textit{debug} de código, de análise de arquitetura, níveis de hierarquia de componentes gráficos, testes de desempenho, acesso a memória flash e outros recursos do dispositivo via IDE, entre outras funcionalidades.  O SDK deve ser baixado separado e corretamente configurado se a ferramenta escolhida para desenvolvimento for o Eclipse. Todas essas funcionalidades estão inclusas no Android Studio, que foi feito especificamente para construção de aplicativos Android.

Após fazer o download do \textit{Android Studio}, basta fazer o download das APIs desejadas durante a própria instalação do mesmo e utilizar do recurso da própria IDE para criar um projeto Android~\footnote{\url{https://developer.android.com/tools/projects/index.html}}, que já vem com uma estrutura pronta para ser trabalhada, separando e categorizando código fonte e outros recursos utilizados no desenvolvimento. O Eclipse IDE foi utilizado como padrão por um bom tempo antes do lançamento oficial do Android Studio, e também monta uma boa estrutura de projeto, embora diferente da utilizada pelo Android Studio.

É necessário especificar a versão alvo do sistema para o qual se está desenvolvendo. Para manter a compatibilidade, geralmente desenvolvedores utilizam como versão mínima a 2.3 ou anterior, embora para utilizar alguns recursos seja necessário utilizar uma API mínima mais recente. Todas as APIs utilizadas precisam ser baixadas pela própria ferramenta de download do SDK ou automaticamente na instalação da IDE. Para desenvolver para Android kitkat 4.4.2 com compatibilidade com Android 2.3 por exemplo, deve-se obter ambas APIs. Cada vez mais as versões mais antigas estão deixando de ser utilizadas. Desenvolvedores de versões alternativas do Android como o Cyanogemod, vem dando suporte e oportunidade de update da plataforma para dispositivos cujo suporte para atualizações já foi abandonado pelo próprio fabricante, ajudando a fazer com que mesmo usuários mais antigos possam utilizar versões mais recentes do sistema Android. A grande maioria dos dispositivos em 2015 já utiliza API maior que a 15 segundo a própria ferramenta de desenvolvimento.

Juntamente com o SDK, o desenvolvedor tem acesso a uma ferramenta de criação de dispositivos virtuais AVD (\textit{Android Virtual Devices}) para poder executar as aplicações sendo desenvolvidas sem a necessidade de um dispositivo físico disponível para esse fim. Entretanto vários recursos do sistema não podem ser utilizados por dispositivos virtuais, como por exemplo o GPS e o bluetooth. Nesses casos, é necessário um dispositivo físico para o desenvolvimento de aplicativos. Qualquer dispositivo pode ser utilizado, desde que a versão Android que ele apresente seja compatível com o aplicativo sendo desenvolvido e tenha ativado no sistema as opções de depuração USB. 

Para o desenvolvimento para o AOSP, é necessário um dispositivo com \textit{bootloader} desbloqueável, de forma que seja possível fazer o flash das imagens geradas pela compilação do sistema no dispositivo físico. Os dispositivos Nexus distribuídos pela própria Google são os mais recomendados para desenvolvedores e contribuidores para o código do sistema, uma vez que todos tem seu \textit{bootloader} desbloqueado e podem ser modificados mais facilmente. Muitos dispositivos, embora não todos, podem ser utilizados para esse fim, desde que tenham \textit{bootloader} desbloqueado. É importante ressaltar que fazer \textit{flash} das imagens do sistema para um dispositivo físico requer que o mesmo seja restaurado para configuração de fábrica, removendo todos os dados presentes no mesmo, e resultará na perda de outras versões anteriormente instaladas do sistema. É preciso ter bastante cuidado para não danificar o dispositivo físico tentando fazer instalação de outras versões do sistema sem tomar as precauções necessárias.

Quando se desenvolvendo para o AOSP, é mais difícil ter uma visão total do software sendo modificado, pois o código fonte do sistema é muito extenso. Para carregar todo o código da api Java na memória da IDE Eclipse por exemplo, é necessário fazer uma alteração nas configurações da ferramenta para que ela utilize mais memória (talvez alguns GB de RAM sejam necessários). Muitas vezes a melhor solução é fazer modificações isoladas em arquivos distintos em algum editor de texto qualquer sem ter o recurso de compilação automática das IDEs que ajudam a identificar erros em tempo de codificação. Nesses casos é necessária uma maior experiência do desenvolvedor para uma modificação consciente e cuidadosa nos arquivos de código fonte do sistema operacional.

\section{Testes}

Testes de software consistem em verificar se o produto de software se comporta da forma esperada em um determinado conjunto de casos específicos, selecionados com o intuito de representar o maior número de situações diferentes que podem ocorrer durante o uso do sistema, com o software em execução. Os testes têm que ser projetados para checar se o software está de acordo com as necessidades do usuário, procedimento conhecido como validação, e para verificar se as funcionalidades estão de acordo com a especificação, procedimento conhecido como verificação \cite{swebok}. Testes podem ser realizados em vários níveis, desde o teste de pequenos trechos de código até a interação entre componentes e o teste da interface gráfica do usuário.

Existem vários tipos de testes aplicáveis a determinados tipos de sistema. De acordo com as necessidades e o ambiente onde o sistema irá funcionar, vários testes podem ser ou não necessários para garantir o funcionamento do sistema sob diversas condições. Sistemas web podem exigir testes de carga e stress para avaliar a quantidade de usuários simultâneos suportados, por exemplo. Sistemas críticos já também necessitam de testes de recuperação, para avaliar a capacidade do sistema de manter ou restaurar seu funcionamento após algum tipo de falta.

Ter uma boa suíte de testes é de grande valia para a manutenção de um produto de software, uma vez que sempre que uma modificação precisar ser feita no sistema, é possível verificar de forma automatizada se algum comportamento foi indevidamente alterado pela modificação realizada.

O sistema Android provê um \textit{framework} para testes\footnote{\url{http://developer.android.com/tools/testing/testing\_android.html}} , com várias ferramentas que ajudam a testar o aplicativo sendo desenvolvido em vários níveis, desde testes unitários a testes relacionados ao \textit{framework} de desenvolvimento e a testes de interface de usuário. Todas as ferramentas necessárias para utilizar a API de testes disponível no \textit{framework} de desenvolvimento Android são disponibilizadas juntamente com o Android SDK.

Podem existir classes em Java puro que não utilizam a API de desenvolvimento do Android. Conseguir fazer essa separação de classes que utilizam o \textit{framework} e classes em Java puro pode significar uma maior facilidade em testar determinadas partes da aplicação, uma vez que podem ser diretamente utilizados os já bem difundidos \textit{JUnit tests} para essas classes. Entretanto, muitas classes são construídas através dos componentes, e o funcionamento das mesmas também precisa ser testado.

As suítes de teste no Android são baseadas em \textit{JUnit}, e então da mesma forma que é possível utilizar \textit{JUnit} para desenvolver testes para classes que não utilizam a API Android, é possível utilizar as extensões do \textit{JUnit} criadas especificamente para testar cada componente do aplicativo sendo desenvolvido. Existem extensões \textit{JUnit} específicas para cada componente Android, e essas classes contém métodos auxiliares para criar \textit{Mock Objects}. Estes são criados para simular outros objetos do contexto de execução real do aplicativo.

O kit de desenvolvimento para a plataforma Android inclui ferramentas automatizadas de teste de interface gráfica. O robotium, por exemplo, realiza testes de caixa preta em cima da interface gráfica do aplicativo. São criadas rotinas de teste em Java semelhantes ao \textit{JUnit}, com \textit{asserts} para validar os resultados. Com ele é possível criar rotinas robustas de testes para validar critérios de aceitação pré-definidos, simulando interações do usuário com uma ou várias \textit{activities}. Existe a ferramenta Monkeyrunner, onde se cria \textit{scripts} em Python para instalar e executar algum aplicativo, enviando comandos e cliques para o mesmo, e salvando \textit{screenshots} do dispositivo no computador com resultados. Há também a ferramenta Monkey, que é utilizada para fazer testes de stress no aplicativo gerando inputs pseudo aleatórios.

\input{capitulos/biodyn}

\end{apendicesenv}
