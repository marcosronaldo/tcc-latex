\chapter{Metodologia}

Metodologia

	- Trabalhos relacionados
    - Arquitetura em android.
	- Métricas utilizadas em sistemas android.
	- Machine learning em análise estática de código.

	Questão de pesquisa: 
		- é possivel monitorar as métricas estáticas de código fonte de app android de acordo com analise e predição da evolução do código do sistema.
		- Usar o próprio sistema como arquitetura referencia devido ao acoplamento do app e a própria API.

	Hipóteses		
			-> O desenvolvimento de aplicativos android pode ser guiado pelo resultado de uma análise evolutiva do código do próprio sistema	
			-> É possível identificar padrões e tendências na evolução da arquitetura do sistema android e nos aplicativos desenvolvidos para ele.			
			*-> As decisões arquiteturais teóricas aplicadas no estudo de caso biodyn estão relacionadas com decisões arquiteturais baseadas em métricas.
			
			Hipótese adicionais*****(dependendo dos resultados)			
			-> É possível traçar um perfil de design para um desenvolvedor, ou equipe de desenvolvimento, e assim detectar aplicativos de sua autoria.

		Teste de hipóteses		
			-> Coleta de dados (fontes, como, pq)			
			-> Coleta de métricas (como e onde foram aplicadas e pq)			
			-> Análise dos dados (O QUE - estatística, ML. Se ML, qual método...)

		Explicar aplicação de método ML no contexto 

Discussão resultados

\section{section}

O objetivo geral deste trabalho é realizar uma análise da API do sistema Android a partir de uma análise estática de seu código fonte, e então avaliar a possibilidade de utilizar os resultados como referência para o desenvolvimento de aplicativos desenvolvidos para o Android, partindo da premissa que os aplicativos desenvolvidos utilizando a API do sistema são fortemente dependentes da mesma.

A partir da análise do código fonte, traçar um perfil que caracteriza o próprio sistema a partir de suas métricas de código fonte, assim como traçar esse perfil para os aplicativos do sistema e verificar o grau de aproximação que ambos encontram em seu design. 

Assumindo que o código dos aplicativos do sistema possuem a arquitetura ideal de aplicativos por serem mantidos pela Google, bem como pela comunidade de desenvolvedores por ter código aberto, criar então um fator de aproximação para aplicar em aplicativos em desenvolvimento para avaliar sua qualidade de acordo com a aproximação ao sistema e à aplicativos nativos, em termos de métricas estáticas de código. Esse fator de aproximação pode ser calculado utilizando métodos estatísticos ou aprendizado de máquina, de forma que possa ser avaliada a aproximação de uma nova amostra aos "perfis existentes".

Caso o grau de aproximação de um aplicativo qualquer seja bastante elevado, pode-se inferir uma boa qualidade de código, pelo fato de se aproximar àquelas desenvolvidas pelos próprios arquitetos do sistema.

Utilizar para isso métricas de código orientado a objeto, bem como outras métricas que refletem decisões arquiteturais e de design. É importante incluir métricas que refletem o volume de código para dar resultados relativos ao tamanho do aplicativo sendo avaliado, uma vez que várias métricas tem seu valor de referência variável de acordo com o tamanho do código. Utilizar valores do sistema, como milhões de linhas de código, como referencia para análisar um aplicativo com apenas algumas centenas de linhas resulta em uma comparação inválida para os valores de algumas métricas.

**(parágrafo de hipóteses, apenas um brainstorming)
Algumas conclusões talvez já possam ser tiradas de acordo com a aproximação do código do sistema aos aplicativos nativos. Como avaliar o quanto as métricas de aplicativos devem se aproximar às do sistema, se os aplicativos nativos forem a referencia. Por exemplo, dos aplicativos nativos, se os resultados mostrarem que nenhum se aproxima a mais de 70\% do sistema, então pode-se inferir que aproximaçao maior que 70 não é desejada em aplicativos de terceiros. Da mesma forma, uma aproximação muito alta pode indicar realmente uma alta dependencia da plataforma e portanto é possível utilizar os valores da mesma como referência, utilizando os aplicativos para gerar mais amostras relativas de tamanho.

\section{Coleta de Dados}

O código fonte para análise foi retirado diretamente do Android Open Source Project (AOSP) (link). Esse código é mantido essencialente pela Google, com colabororação da comunidade de desenvolvedores. Essa versão é mantida e evoluida para funcionar como base para que as fabricantes de dispositivos possam manter sempre a ultima versão do sistema, com atualizações funcionais e de segurança, enquanto trabalham em ideias inovadoras para melhorar a experiência de usuário de seus dispositivos. A Motorola, por exemplo, tem o seu sistema levemente modificado para incluir algumas funcionalidades em seus produtos, assim como várias outras grandes fabricantes como a Samsung, LG e outras.  Essa forma de manter o sistema aberto e altamente customizável mantém uma competitibilidade entre as empresas, pois partindo do mesmo sistema base, todas as fabricantes entregam a seus clientes dispositivos com essencialmente as mesmas funcionalidades, com exceção das pequenas modificicações, em um sistema operacional robusto e estável.

 A ferramenta repo é utilizada para unificar os projetos internos dos componentes do sistema em seus repositórios, e um tutorial para configurar a ferramenta e fazer o download do projeto pode ser encontrado no site do AOSP.

Para a análise da API do sistema, foram escolhidas cerca de 15 versões do sistema, selecionando arbitrariamente a primeira e a última versão de cada grande release. Por exemplo, para o Android Eclair, foram pegas as versões XXX e XXX, e para o Kitkat, as versões XXX e XXX. Para o Android Lollipop, a última versão selecionada não será a ultima antes da próxima grande release, mas sim a última lançada até a data de início deste trabalho. Em uma análise ideal, todas as versões possíveis seriam levadas em cosideração, mas o motivo dessa escolha de versões foi a impossibilidade de realizar uma análise do código fonte de todas as versões para este trabalho, por limitações de tempo e de recursos computacionais. Portanto, foram escolhidas as versões iniciais de cada grande release onde é alterado o codenome da versão, que contém grandes mudanças e significativos avanços no sistema, assim como as versões finais de cada codenome, que representam as versões mais estáveis das funcionalidades adicionadas nas versões com aquele codenome.

 Cada versão escolhida corresponde a uma TAG no repositório oficial. Segue a listagem das tags escolhidas:
- 
-
-

Para cada tag, foi criado um diretório separado em um sistema Debian, onde foi executada o comando "repo -init" com um complemento específico para setup inicial daquela tag. Esse comando prepara o diretório e cria arquivos de controle da ferramenta para o repositório que está sendo iniciado. São baixados alguns arquivos, como por exemplo o arquivo em xml, chamado manifest, que contém os projetos ou repositórios que compõe o sistema, todos para a tag específica que foi iniciada. Antes de fazer o download do código, foram retirados do manifest da ferramenta todos os subprojetos que não estavam contidos dentro da pasta "frameworks", que é o principal alvo da análise. Desas forma só os projetos de interesse são baixados quando o download for feito. Essa escolha se deu pelo fato de que grande parte do código java da API do sistema utilizado no desenvolvimento de aplicativos se encontra neste local. Cyanogenmod, criadores de uma das maiores e mais conhecidas versões alternativas ao AOSP, mantida por colaboradores voluntários em paralelo ao código da Google, citam em sua página de ajuda a desenvolvedores (link pra wiki cyanogenmod) que o diretório "frameworks" é onde se encontram os "hooks" que programadores usam para construir seus aplicativos, ou seja, a API de construção de aplicativos em geral. O restante dos diretórios do AOSP contém desde adaptações de bibliotecas para o Android como o bionic, até código fonte para o Android Run Time (ART), que subistituiu a dalvik nas ultimas versões do sistema (especificamente desde as versões de codenome Lollipop), e também códigos de baixo nível específicos para alguns dispositivos. Também existem diretórios para projetos externos ao Android, utilizados pelo mesmo, como o SQLite e outros projetos externos. O kernel utilizado no sistema também tem o seu diretório nessa hierarquia, assim como os aplicativos nativos. A estrutura completa do AOSP não será explorada neste trabalho, mas o conteúdo da pasta raiz pode ser visualizado na figura XXX.

(figura da estrutura de diretórios do AOSP)

A estrutura de diretórios onde foram preparados os códigos para a análise pode ser vista na figura X.

(imagem com estrura de diretórios)

Em seguida foi feito o download de cada tag em seu diretório, também utilizando a ferramenta repo, que realiza um checkout de cada suprojeto listado em seu manifest através do comando sync. O total de espaço em disco ocupado após o download de todas as TAGS foi cerca de XX GB. É importante notar que boa parte deste espaço corresponde a arquivos de mídia ou outros formatos que fazem parte do sistema mas não serão analisados por não corresponderem a código fonte. Não foi realizado nenhum tipo de filtro para remover esses arquivos nem antes nem durante a análise estática de código, porém isso afeta apenas a performace da ferramenta de análise, mas os resultados permanecem sem interferencia.

Após o download de todas as versões escolhidas, foi utilizada a ferramenta Analizo(link) para análise estática de código e coleta de métricas. Um dos motivos da escolha do sistema Debian foi a facilidade de instalação da ferramenta. O Analizo é uma ferramenta livre e extensível para análise de código com suporte a várias linguagens, incluindo java, que será o foco da análise neste trabalho. Uma grande quantidade de métricas são coletadas pela ferramenta, embora apenas algumas sejam utilizadas para  esta análise. Foram coletadas essencialmente métricas de código fonte orientado a objetos. São métricas desse tipo que melhor refletem as decisões arquiteturais ou de design aplicadas durante o desenvolvimento do sistema.

Neste trabalho, foi utilizada a funcionalidade de batch do Analizo, de forma a coletar métricas de todas as tags de uma só vez. A saída da ferramenta é um arquivo CSV para cada projeto ou versão a ser analisada, assim como um arquivo CSV que centraliza os valores de cada métrica a nível de projeto para cada um dos projetos/versões. Isso pode ser interessante quanto utilizado com o mesmo projeto em diferentes versões para verificar o avanço de algumas métricas juntamente com a evolução do sistema.

(comentar sobre as métricas escolhidas e pq. explicar o que cada uma significa)