\chapter{Métricas de Código}
\label{cap:metricas}

A ISO/IEC 9126, reunida agora na ISO/IEC 25000, apresenta características de qualidade e um guia para o uso dessas características, de forma a auxiliar e padronizar o processo de avaliação de qualidade de produtos de software. Ela separa qualidade em software essencialmente em qualidade interna e qualidade externa. Qualidade externa é a visão do produto de software de uma perspectiva externa, resumindo-se basicamente em qualidade do sistema em execução. Já a qualidade interna trata da visão interna do produto de software, podendo incluir documentos, modelos e o código fonte. A qualidade interna pode começar a ser medida em estágios mais iniciais do desenvolvimento por não haver ainda nesses estágios uma visão externa do sistema. Esses valores de qualidade interna podem ser utilizados para prever os valores de qualidade externa que o produto vai apresentar. É importante perceber essa relação entre qualidade interna e externa para perceber que qualidade interna impacta fortemente na qualidade externa de um produto, e então observar a importância de começar esforços de medição e acompanhamento da qualidade interna desde o início do projeto. A avaliação de qualidade de código fonte no início do desenvolvimento pode ser de grande valia para auxiliar equipes inexperientes durante as etapas seguintes do desenvolvimento de software.

Neste trabalho, serão trabalhadas métricas estáticas de código fonte para avaliar a qualidade de um produto de software através de suas decisões arquiteturais, que são refletidas essencialmente nas métricas OO e métricas de complexidade. Métricas de tamanho serão utilizadas com o objetivo de relacionar as demais métricas de forma relativa em vez de uma comparação direta. Complexidade tem forte relação com o tamanho do código, e a necessidade de manter as duas é justificada para realizar análises mais adequadas e chegar a resultados mais consistentes.

\section{Métricas utilizadas}

Várias métricas podem ser utilizadas para avaliar quantidade de código fonte, como por exemplo \textit{Lines of Code (LOC)} ou mesmo métricas de tamanho e volume de halstead. Manter o monitoramento de métricas de volume de código em conjunto com outras métricas é de extrema importância para que comparações sejam feitas para sistemas de tamanho semelhante. Comparar um pequeno applicativo de 2 classes com o código de um sistema operacional não apresenta resultados válidos. Essas métricas de tamanho devem ser consideradas para que as comparações sejam feitas de forma adaptada para a "escala" de tamanho dos softwares sendo comparados. LOC pode ser bastante representativa para qualidade de software e probabilidade de erros em código \cite{validationmetricsfaultprediction}, e é uma métrica extremamente simples e rápida de ser coletada. Essa é a melhor escolha em termos de tamanho de código para o início deste trabalho devido a sua simplicidade, embora este estudo possa ser futuramente expandido com a utilização de métricas adicionais, para complementar ou substituir essa métrica. Não será levada em consideração a comparação entre diversas métricas neste trabalho, baseando a escolha então totalmente na simplicidade e na ferramenta escolhida para coleta, devido a limitações de tempo e escopo.

\citeonline{ooasqualityindicators} apresenta um estudo com métricas de Chidamber e Kemerer, introduzidas por \citeonline{chidamberkemerer}, que são métricas para sistemas orientados a objetos, para avaliação da arquitetura do sistema e qualidade do código fonte. Essas métricas são bastante úteis para prever estados futuros já nas primeiras etapas do ciclo de vida. Tais métricas podem ser bastante úteis como indicadores de qualidade de sistemas orientados a objetos\cite{ooasqualityindicators}. 

Métricas de complexidade também dão uma visão do estado atual do software no que diz respeito a escolhas arquiteturais e facilidade de compreensão do mesmo e também tem impacto direto na facilidade em que o software pode ser testado e mantido. Métricas de complexidade ciclomática, introduzidas por \citeonline{mccabe1976}, foram criadas para avaliar a quantidade de caminhos que a execução do software pode seguir em sua execução, dando uma boa visão dos possíveis casos de teste para o software. Demonstrar que um software possui muitos caminhos paralelos de execução para serem testados pode demonstrar um grande esforço com testes, bem como um sistema bem difícil de manter com o passar do tempo. Da mesma forma, um software com baixa capacidade ciclomática indica um software que pode ser testado mais facilmente, podendo indicar um menor esforço futuro com possíveis modificações. Há outras métricas bem difundidas para avaliar a complexidade de software, como as métricas de Halstead que associam tamanho, volume, dificuldade e esforço. As métricas de halstead podem ser consideradas como métricas de tamanho, embora possam ser derivados vários valores com significados distintos das métrica básicas apresentadas. Essas métricas não são diretamente compatíveis pois medem coisas diferentes, mesmo usando "complexidade" como terminologia, e seus resultados levam a conclusões completamente distintas.

É importante ressaltar que as métricas discutidas neste capítulo, utilizadas durante todo o estudo, são coletadas de forma unificada pela ferramenta Analizo, o que foi um dos motivos de sua escolha.

\subsection{Descrição das métricas}

(listar e explicar cada uma)
