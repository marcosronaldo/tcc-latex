\chapter{Estudo de Caso}

\section{E-Lastic}
O E-lastic é um sistema eletrônico que monitora e controla a execução de exercícios físicos realizados com equipamento que impõe sobrecarga à movimentação de segmentos corporais por meio de resistência elástica. Geralmente o controle de sobrecarga gerada por elementos elásticos é baseado na percepção subjetiva do esforço, com base na sensação de fadiga experimentada durante o exercício, e portanto o praticante não têm controle do esforço aplicado no exercício.

O produto em desenvolvimento apresenta um aparelho portátil, voltado para o controle de atividades físicas em ambientes fechados ou abertos. Trata-se de um sistema eletrônico embarcado que realiza o processamento digital do sinal originado num sensor de força e associa essas informações com variáveis de espaço e tempo, de forma a gerar informações suficientes para o controle e prescrição de exercícios resistidos. O sensor de força será fornecido calibrado juntamente com a central de processamento. Esse sistema eletrônico permite a acoplagem do implemento elástico para a realização do exercício a ser monitorado, e interfaceia com o usuário por meio de um aplicativo desenvolvido para um dispositivo móvel. De forma geral, durante o exercício físico, a força aplicada pelo usuário ao elemento elástico é calculada no microcontrolador e enviada juntamente com as demais informações via Bluetooth para um dispositivo móvel com o e-lastic app, que contém opções de controle para a realização do exercício físico.

Para a utilização do aparelho, o usuário deve selecionar o implemento elástico mais adequado ao exercício que será praticado, com resistência elástica compatível com o esforço que será aplicado. Um sensor de força compatível é acoplado ao implemento elástico e ligado ao módulo de processamento por uma entrada específica. O usuário então seleciona via aplicativo móvel um dos três modos de execução de exercício: dinâmico, isométrico e potência. Seleciona em seguida a configuração da sua rotina de treino, com os parâmetros de controle para o exercício específico. A partir daí o exercício pode ser iniciado, e informações precisas de controle são apresentadas na tela do dispositivo móvel em tempo real. Vibração do dispositivo, estímulos sonoros e outros tipos de sinais podem ser utilizados para dar biofeedback ao usuário sobre o exercício em curso. Após a realização do exercício, é apresentado um resumo da seção de treino executada. É possível que se apresente um histórico de treinamento dos indivíduos que realizam suas atividades utilizando o e-lastic.

Os parâmetros para controle podem variar de exercício para exercício, porém em todos eles será selecionado um intervalo de intensidade, isto é, carga máxima e mínima em quilogramas, em que o exercício será trabalhado. As opções de exercícios são espécies de rotinas pré programadas, modos de utilização da resistência elástica para o exercício físico:

\begin{enumerate}
\item Modo dinâmico - Realização de movimentos cíclicos em velocidade lenta e cadência controlada. Os parâmetros de controle para esse exercício são número de séries de exercícios, número de repetições por série e a duração do descanso entre as séries.
\item Modo isométrico - Contrações estáticas em que o usuário mantém uma posição e sustenta a sobrecarga elástica nessa posição por um determinado tempo. Semelhante ao modo dinâmico, no modo isométrico o usuário seleciona os parâmetros de números de contrações realizadas (repetições do exercício), e duração do tempo de intervalo entre as séries, com adição da duração de cada contração, isto é, o tempo em que o esforço deve ser mantido para que uma repetição seja contabilizada.
\item Modo potência - Semelhante ao modo dinâmico, estes são exercícios cíclicos, porém com a maior velocidade possível. Os parâmetros para esse exercício são os mesmos do modo dinâmico, porém aqui a velocidade do movimento faz parte dos parâmetros de controle.
\end{enumerate}

\section{Desenvolvimento}

O e-lastic começou como um produto desenvolvido para interfacear com usuário por modo de um dispositivo específico conectado ao sensor de força via cabo. A seleção dos exercícios e o próprio feedback para o usuário eram realizados por meio desse dispositivo, fazendo interação com o usuário por meio de um display LCD e um potenciômetro para seleção de parâmetros de exercício, e o feedback sendo feito por meio de LEDs e sinais sonoros, bem como o próprio display LCD. Esse produto é resultado do trabalho de mestrado em processamento de sinais da aluna Fernanda Sampaio Teles, que resultou num pedido de patente com número de registro BR 5120130007631.

Por volta de 1 vez ao mês, foram realizadas reuniões com Fernanda e também Gabriela Sartório, também aluna de processamento de sinais trabalhando nesse projeto. Daqui em diante serão referenciadas neste documento como \textit{product owners}.

Os requisitos para o aplicativo foram a principio retirados do próprio comportamento dos primeiros protótipos. Esses comportamentos foram descritos e detalhados pelos product owners, que não só descreveram como os protótipos funcionavam, como também foi discutido como o aplicativo deveria se comportar de forma diferente dos mesmos, com adições de novas funcionalidades para o aplicativo sendo desenvolvido.

A ideia inicial do aplicativo, e foco principal do desenvolvimento da equipe ao longo desse semestre, foi fazer com que o aplicativo sendo desenvolvido para plataforma Android tenha no mínimo as mesmas funcionalidades dos primeiros protótipos. 

O desenvolvimento do e-lastic app ao longo do semestre foi planejado e executado juntamente com a disciplina de Manutenção e Evolução de Software (MES). Desde o início do semestre, foi preparada uma equipe na disciplina para o desenvolvimento do aplicativo desde o início, de forma a preparar a base da arquitetura. Essa base será utilizada na segunda fase deste trabalho, quando o desenvolvimento será focado em alcançar todos os objetivos traçados nas reuniões com os product owners, que se resumem basicamente na construção e entrega do aplicativo completo e funcional.

Para este trabalho em conjunto com a disciplina de MES durante o semestre, o objetivo principal é conseguir uma base de arquitetura e alcançar dois tipos de exercícios com funcionalidade implementada: exercício dinâmico e isométrico. A interface gráfica foi deixada em segundo plano durante esse período de desenvolvimento, com o foco voltado então em uma base estável e manutenível com as funcionalidades básicas implementadas e com seus respectivos testes.

\subsection{Ciclo de desenvolvimento}		

Durante o desenvolvimento, foram utilizadas práticas ágeis retiradas do Scrum. Embora o Scrum não esteja no escopo deste trabalho, informações sobre o mesmo podem ser obtidas em \citeonline{scrum}.

Devido ao ritmo de trabalho mais lento proporcionado pelo tempo curto da disciplina de MES, as sprints foram planejadas para durar 15 dias (2 semanas). Inicialmente foram criadas várias histórias de usuário (user stories) e montado um backlog considerando a reunião inicial com os product owners. Novas histórias surgiam, bem como histórias iam sendo atualizadas conforme os requisitos ficavam mais claros com as reuniões subsequentes. A cada 2 semanas então eram consideradas as histórias de usuário do backlog e priorizadas para a iniciar a sprint. Nas medidas utilizadas pela equipe, com pontuação de 1 a 5 para cada história utilizando técnica do planning poker, foi implementada uma média de 7 story points por sprint. É importante ressaltar que histórias não completadas não entram nem parcialmente nesse cálculo e são jogadas para as sprints seguintes, e portanto para uma equipe inexperiente em constante aprendizado é possível inferir que mais esforço foi dedicado do que o próprio velocity pode indicar, representando a curva de aprendizado da equipe. Muito do meu esforço foi direcionado ao aprendizado da equipe para alavancar o desenvolvimento do aplicativo.

Todo trabalho realizado foi feito utilizando técnica de programação em pares. Um quadro mapeando os integrantes que já trabalharam juntos esteve em constante atualização para que a equipe circulasse da melhor forma possível. Participei do desenvolvimento dessa forma várias vezes ao longo do semestre, mesmo esse não sendo o objetivo principal da minha contribuição no desenvolvimento, com o intuito de compartilhar de parte do conhecimento da plataforma que obtive no projeto com parceria UnB-Positivo de desenvolvimento de aplicativos Android, bem como conhecimento que adquiri em estágio no ICRI-SC (Intel Collaborative Research Institute for Security Computing), localizado em Darmstadt, Alemanha.

O código sendo desenvolvido se encontra disponível em um repositório aberto\footnote{\url{http://gitlab.com/biodyn/biodynapp}} para qualquer desenvolvedor através da plataforma gitlab.com, e a equipe de alunos de MES não tem acesso direto de escrita para esse repositório. Para contribuir para o projeto, a equipe trabalha em uma cópia do repositório original (fork). Quando alcança algo significativo para o projeto, a equipe então cria um \textit{merge request} pela própria plataforma gitlab, que é então avaliado e aceito por mim, ou rejeitado e mudanças são solicitadas. O mesmo procedimento pode ser realizado por qualquer desenvolvedor que deseja contribuir com o projeto. Como já dito, o software sendo desenvolvido é livre e portanto tem código aberto disponibilizado online. A única parte do produto e-lastic que será comercializada é o componente físico, com o módulo central de processamento, sensor de força e implemento elástico.

\subsection{Equipe}
Composta por 5 alunos da disciplina de MES, a equipe contém apenas graduandos em Engenharia de Software da Universidade de Brasília campus UnB Gama. Todos eles tem um tempo a dedicar ao desenvolvimento correspondente ao tempo de uma disciplina de 4 créditos, com 4 horas-aula e mais 4 horas semanais adicionais por integrante, totalizando 8 horas por semana de dedicação para cada um dos integrantes da equipe.

Todos os integrantes não tinham a priori nenhuma experiência no desenvolvimento de aplicativos para a plataforma Android, porém todos eles tinham algum conhecimento em linguagem de programação Java, necessária ao desenvolvimento, bem como experiência em atividades de verificação e validação, banco de dados, entre outras áreas. Todo esse conhecimento foi adquirido ao longo do curso de graduação em Engenharia de Software que está em andamento, provendo o background necessário para que eles pudessem trabalhar neste projeto durante o semestre. A equipe também apresentou conhecimento suficiente em gerência de configuração e controle de versionamento, o que ajudou significativamente em relação a manutenção do repositório do projeto.

Um dos integrantes da equipe faz o papel de \textit{coach}, coordenando o restante da equipe para alcançar os objetivos de cada sprint e tomando frente da organização da equipe ao longo dos ciclos de desenvolvimento. Embora tenha essa responsabilidade adicional, esse integrante participava das atividades de desenvolvimento tanto quanto os demais, e foi selecionado para esse papel pelo professor da disciplina por ter mais experiência que os demais em metodologia ágil de desenvolvimento de software.

O principal papel que exerci ao longo do desenvolvimento foi em relação ao estabelecimento da arquitetura do aplicativo sendo desenvolvido, visto que a equipe não tinha experiência com componentes do Android e não conhecia a própria estrutura de um aplicativo para essa plataforma. Dessa forma, fiquei responsável por criar a estrutura base para o desenvolvimento do aplicativo, bem como revisar todos os códigos submetidos para o repositório principal, e solicitar modificações caso não estivessem de acordo com a arquitetura base do repositório principal, ou não estivesse com qualidade aceitável. Como participei ativamente do desenvolvimento, não houve muita surpresa nos merge requests e portanto poucos foram rejeitados.

Durante as aulas da disciplina de MES, toda a equipe esteve presente comigo, onde era aproveitado o tempo em conjunto para a disseminação do conhecimento sobre a plataforma. Por várias vezes foram feitos DOJOs de treinamento comigo para que o conhecimento circulasse dentro da equipe. Com o mesmo objetivo, a equipe sempre trabalhou em revezamento de pares e de tarefas. Uma dupla que trabalhou com um módulo específico durante uma semana passava a trabalhar em outro na semana seguinte, ou mesmo em atividades de teste, com outra dupla assumindo o trabalho da anterior. Os demais horários da equipe variam de acordo com a semana e com a dupla que trabalhará na semana. As duplas sempre alternavam, e os horários para cada dupla dependem da disponibilidade dos integrantes. Nesses horários de desenvolvimento, não participei de forma presencial e não houve participação de toda a equipe, cada dupla trabalhava em uma parte separada da aplicação.

Como os conhecimentos em desenvolvimento Android foram adquiridos ao longo do desenvolvimento, a primeira sprint teve menor velocity que as demais, como demonstrado na imagem BLABLA.
%TODO verificar velocity da equipe e fazer grafico e referenciar na linha anterior

Embora meu papel principal fosse como arquiteto e revisor de código, também participei da codificação do aplicativo, codificando e construindo boa parte dos principais componentes desenvolvidos ao longo do semestre. Um dos motivos para isso foi dar o impulso inicial que a equipe inexperiente na plataforma precisava para trabalhar de forma mais eficiente.

\section{Estado do desenvolvimento}

O planejamento do desenvolvimento para a equipe da disciplina de MES foi focado na base da arquitetura, juntamente com a funcionalidade básica do aplicativo. Isso inclui o modo de exercício dinâmico e exercício isométrico com seus respectivos testes funcionais, e a comunicação com o microcontrolador via Bluetooth para o funcionamento dos exercícios. A interface gráfica de usuário foi deixada em segundo plano durante essa etapa do desenvolvimento, tendo apenas alguns componentes temporários apresentados na tela para ajudar na visualização da funcionalidade que foi desenvolvida. Ainda durante esse período de colaboração com a equipe de MES, também deve ser entregue a persistência dos parâmetros de execução dos exercícios, de forma que o usuário possa salvar suas preferências e carregá-las para reutilizar os mesmo parâmetros da proxima vez que praticar o exercício.

Nesta seção, serão chamados de componentes instanciações dos componentes Android, e de módulos conjunto mais complexo de classes que envolvem um ou mais componentes. Na implementação atual do aplicativo, exitem os seguintes componentes e módulos principais:
\begin{itemize}
	\item BluetoothService - Responsável pela conexão bluetooth, este componente é um Android Service que se inicia juntamente com a aplicação e fica a espera de uma solicitação de conexão vinda da tela de escolha de dispositivos. Quando o usuário solicita a conexão com o hardware e-lastic selecionando-o em uma lista, o app identifica o dipositivo a ser conectado e informa ao BluetoothService, que a partir daí é responsável por conectar e manter a conexão, recebendo os dados do microcontrolador presente no hardware e-lastic.
	\item ExerciseService - Este módulo reúne a maior parte da lógica de negócio. Ele gerencia qual é o exercício ativo e trata da execução do mesmo. Quando recebe um dado de força vindo do bluetoothService, o exerciseService informa ao exercício ativo os novos valores recebidos. Da mesma forma ele informa ao exercício sobre mudanças nos parâmetros vindas da interação com o usuário com o a tela do aplicativo.
	\item BioFeedbackService -Este módulo é responsável por gerar biofeedback para o usuário. Quando o valor de força é superior ao limite máximo, por exemplo, o exercício informa a esse componente que algum tipo de feedback deve ser acionado para informar ao usuário que o limite foi ultrapassado. Por sua vez, este componente checa sua lista de biofeedbacks e aciona os que foram solicitados. Por exemplo, pode ser solicitado que o dispositivo móvel vibre quando os limites de força forem violados, como também pode ser requisitado que um som seja tocado. Essas configurações de que tipo de biofeedback ativar estarão disponíveis para o usuário na versão final do aplicativo.  
	\item ExerciseActivity - Representa a tela principal e a própria interação do usuário com os componentes gráficos. Este componente não será implementado neste período de desenvolvimento com parceria com a equipe de Manutenção e Evolução de software, e será trabalhado apenas na segunda etapa deste trabalho de conclusão de curso. Neste período, apenas alguns componentes gráficos temporários estão disponíveis para demonstrar a funcionalidade básica do aplicativo em execução.
\end{itemize} 

A comunicação de todos os componentes e módulos é feita de forma indireta por meio de intents. Como já citado em capítulos anteriores, o intent tem a função de comunicar componentes independente da aplicação a qual pertencem. Entretanto, neste aplicativo em desenvolvimento, essa comunicação deve ser feita apenas entre os componentes internos da aplicação, não sendo necessário que esses intents entre os componentes internos sejam enviados pelo sistema Android para outros componentes de outras aplicações. Para esse fim, a implementação foi feita utilizado um recurso da API Android chamado "LocalBroadcastManager", que é responsável por realizar o envio de broadcast intents apenas para os componentes internos da aplicação, evitando que os mesmos sejam recebidos em outras aplicações. De forma análoga, os receptores desses intents são registrados não diretamente no sistema, mas dentro dessa instância de "LocalBroadcastManager" que é individual da aplicação, registrando-se apenas para receber intents enviados dentro da própria aplicação. O uso desse recurso evita a necessidade de criar permissões específicas para cada tipo de intent que será utilizado entro da aplicação, e não há perigo de que a aplicação receba intents forjados por alguma outra aplicação maliciosa ou mesmo que alguma aplicação maliciosa receba dados que são privados deste aplicativo.

Toda essa comunicação indireta foi reunida em uma classe responsável por gerenciar essas comunicações, a classe \textit{Communicator}. Essa classe reúne todas as actions de todos os intents que as classes estão preparadas para receber. Basicamente, para saber que informações o ExerciseService espera, por exemplo, basta checar as constantes na classe "Communicator.ExerciseServiceActions". Embora essa classe pareça ter um alto acoplamento devido a sua responsabilidade de comunicar todos os componentes, esse acoplamento é reduzido devido a comunicação indireta que é feita com o uso de itents. Simplificando, a classe Communicator tem a responsabilidade de enviar mensagens para todos os componentes sem realmente os conhecer. Se um componente for alterado, não há impacto algum dentro dessa classe.

Essa comunicação indireta que é implementada por meio dos intents tem a vantagem de deixar os componentes com uma conexão bastante fraca. Quando um componente envia uma mensagem, ele não sabe ao certo quem vai receber, portanto não precisa conhecer o receptor. As mensagens são enviadas via broadcast, para todos os componentes, e cada um recebe o que desejar receber. Da mesma forma, os receptores dessas mensagens não sabem quem as mandou, e portanto não há uma associação direta em nenhum dos lados da comunicação. Embora pareça deixar a comunicação confusa e embaralhada, isso permite que troquemos um componente inteiro do projeto com pequeno ou nenhum impacto nos demais componentes. A interface gráfica, por exemplo, recebe mensagens do componente de exercício informando sobre atualizações nos dados. Ela não conhece o exercício em execução e o exercício em execução não conhece quem está mostrando seus dados. Se a interface gráfica fosse inteiramente excluída da aplicação, com pouquíssimos ajustes, relacionados principalmente as mudanças no próprio "AndroidManifest.xml", seria possível deixar várias outras funcionalidades ainda em funcionamento. Com esse acoplamento reduzido entre os componentes da aplicação, se torna muito mais fácil a manutenção e refatoração desses componentes isoladamente, ou mesmo a substituição completa dos mesmos. Trocar o módulo bluetooth por um módulo wifi, por exemplo, que recebe esses dados por socket de rede em vez de bluetooth, não traria quase nenhum impacto a aplicação já em produção, uma vez que esse novo módulo poderia simplesmente enviar mensagens da mesma forma que o bluetooth enviava utilizando a classe Communicator. Como já explicitado, para os demais módulos não importa quem envie os dados, desde que eles cheguem corretamente. 

A única exceção para essa comunicação indireta é a própria inicialização dos componentes. Todos os serviços precisam ser iniciados em algum lugar na aplicação, e o lugar óbvio para o fazer é no início da aplicação. Não tem porque iniciar os componentes enquanto o usuário não abrir a parte gráfica da aplicação, e por esse motivo os serviços são inicializados assim que a Activity principal é criada, uma vez que ela é o ponto de entrada da aplicação e-lastic. Muitos componentes podem ser o ponto de entrada em um aplicativo Android, mas neste caso específico a melhor escolha é a própria interface gráfica, representada pela Activity. Desse modo a activity conhece os serviços a serem inicializados, porém não conhece seu comportamento e nem mesmo sua responsabilidade.

A figura \ref{diagramaComponentes} é um diagrama de componentes que representa de forma gráfica a ideia básica da comunicação entre os componentes da aplicação e-lastic.

\begin{figure}[!htb]
\centering
\includegraphics [keepaspectratio=true,scale=0.60]{figuras/diagramaComponentes.eps}
\caption{Principais componentes da aplicação e sua comunicação via classe Communicator}
\label{diagramaComponentes}
\end{figure}

Embora representado no diagrama de componentes como uma caixa apenas (ExerciseService), o módulo de exercício contém a lógica da comunicação do componente via Communicator e o gerenciamento do exercício em execução. É utilizada a generalização para o service tenha o mesmo comportamento independente do exercício em execução, e portanto as manipulações do exercício são feitas em cima de um objeto do tipo "Exercise", que é uma classe abstrata. A figura ~\ref{diagramaExercicios} contém um diagrama de classes para demonstrar a estruta básica desse módulo.

\begin{figure}[!htb]
\centering
\includegraphics [keepaspectratio=true,scale=0.60]{figuras/diagramaExercicios.eps}
\caption{Principais classes dentro do módulo de exercício e suas relações}
\label{diagramaExercicios}
\end{figure}

As classes internas do módulo de biofeedback podem ser vistas na figura ~\ref{diagramaBioFeedback}. Também é utilizada uma generalização dos tipos de biofeedback com a interface \textit{BioFeedback}, que deve ser implementada para criar um novo tipo de biofeedback. Da mesma forma que o módulo de exercício, aqui também existe um service que fica em segundo plano a espera de uma requisição de execução de biofeedback. Em suma, ele fica em standby até que algum pedaço da aplicação solicite que ele ative algum dos seus tipos de feedback. Reunir essa função em um módulo específico da aplicação faz com que se possa ter controle de quais tipos de biofeedback podem ser utilizados, e eles tem um acesso padrão independente do tipo, com a utilização do Communicator e flags que indentificam que tipos de biofeedback ativar. Tocar um som e vibrar o celular são feitos de formas completamente diferentes, e só a própria classe precisa saber como o fazer, sendo que o service só conhece a interface de início e término e para ela não importa sua implementação. Com a implementação dessa forma, basta uma adição de uma linha de código no mapa de biofeedbacks e a adição de uma flag, além da implementação do novo biofeedback, para que um novo tipo de biofeedback esteja pronto para ser utilizado.

\begin{figure}[!htb]
\centering
\includegraphics [keepaspectratio=true,scale=0.60]{figuras/diagramaBioFeedback.eps}
\caption{Principais classes dentro do módulo de biofeedback e suas relações}
\label{diagramaBioFeedback}
\end{figure}
 
 As explicações neste tópico tem como objetivo principal tentar demonstrar o tipo de comunicação entre as partes da aplicação e a modularização  da mesma, justificando as principais decisões acerca da arquitetura e demonstrando a preocupação da equipe com manutenibilidade e princípios de design. Não serão explorados todos os detalhes da implementação da aplicação desenvolvida, sendo que isso será o alvo da segunda parte deste trabalho.